/**
 * Copyright (c) 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

'use strict';function _asyncToGenerator(fn) {return function () {var gen = fn.apply(this, arguments);return new Promise(function (resolve, reject) {function step(key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {return Promise.resolve(value).then(function (value) {step("next", value);}, function (err) {step("throw", err);});}}return step("next");});};}

const JsFileWrapping = require('../../ModuleGraph/worker/JsFileWrapping');

const collectDependencies = require('../../ModuleGraph/worker/collect-dependencies');
const constantFolding = require('./constant-folding');
const generate = require('babel-generator').default;
const inline = require('./inline');
const minify = require('./minify');var _require =

require('../../Bundler/source-map');const compactMapping = _require.compactMapping;
































































function postTransform(
filename,
localPath,
sourceCode,
isScript,
options,
transformFileStartLogEntry,
ast)
{
  const timeDelta = process.hrtime(transformFileStartLogEntry.start_timestamp);
  const duration_ms = Math.round((timeDelta[0] * 1e9 + timeDelta[1]) / 1e6);
  const transformFileEndLogEntry = {
    action_name: 'Transforming file',
    action_phase: 'end',
    file_name: filename,
    duration_ms,
    log_entry_label: 'Transforming file' };


  let dependencies, wrappedAst;

  // If the module to transform is a script (meaning that is not part of the
  // dependency graph and it code will just be prepended to the bundle modules),
  // we need to wrap it differently than a commonJS module (also, scripts do
  // not have dependencies).
  if (isScript) {
    dependencies = [];
    wrappedAst = JsFileWrapping.wrapPolyfill(ast);
  } else {
    let dependencyData = collectDependencies(ast);

    if (!options.dev) {
      dependencyData = collectDependencies.forOptimization(
      ast,
      dependencyData.dependencies,
      dependencyData.dependencyMapName);

    }

    dependencies = dependencyData.dependencies.map(dep => dep.name);
    wrappedAst = JsFileWrapping.wrapModule(
    ast,
    dependencyData.dependencyMapName);

  }

  const result = generate(
  wrappedAst,
  {
    code: false,
    comments: false,
    compact: false,
    filename: localPath,
    retainLines: false,
    sourceFileName: filename,
    sourceMaps: true },

  sourceCode);


  const map = result.rawMappings ? result.rawMappings.map(compactMapping) : [];

  return {
    result: { dependencies, code: result.code, map },
    transformFileStartLogEntry,
    transformFileEndLogEntry };

}

function transformCode(
transformer,
filename,
localPath,
sourceCode,
isScript,
options)
{
  const isJson = filename.endsWith('.json');

  if (isJson) {
    sourceCode = 'module.exports=' + sourceCode;
  }

  const transformFileStartLogEntry = {
    action_name: 'Transforming file',
    action_phase: 'start',
    file_name: filename,
    log_entry_label: 'Transforming file',
    start_timestamp: process.hrtime() };


  const plugins = options.dev ?
  [] :
  [[inline.plugin, options], [constantFolding.plugin, options]];

  const transformResult = transformer.transform({
    filename,
    localPath,
    options,
    plugins,
    src: sourceCode });


  const postTransformArgs = [
  filename,
  localPath,
  sourceCode,
  isScript,
  options,
  transformFileStartLogEntry];


  return typeof transformResult.then === 'function' ?
  transformResult.then((_ref) => {let ast = _ref.ast;return postTransform.apply(undefined, postTransformArgs.concat([ast]));}) :
  postTransform.apply(undefined, postTransformArgs.concat([transformResult.ast]));
}

exports.minify = (() => {var _ref2 = _asyncToGenerator(function* (
  filename,
  code,
  sourceMap)
  {
    try {
      return minify.withSourceMap(code, sourceMap, filename);
    } catch (error) {
      if (error.constructor.name === 'JS_Parse_Error') {
        throw new Error(
        `${error.message} in file ${filename} at ${error.line}:${error.col}`);

      }

      throw error;
    }
  });return function (_x, _x2, _x3) {return _ref2.apply(this, arguments);};})();

exports.transformAndExtractDependencies = function (
transform,
filename,
localPath,
sourceCode,
isScript,
options)
{
  // $FlowFixMe: impossible to type a dynamic require.
  const transformModule = require(transform);

  return transformCode(
  transformModule,
  filename,
  localPath,
  sourceCode,
  isScript,
  options);

};

exports.transformCode = transformCode; // for easier testing