/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

'use strict';













































// We'll be able to remove this to use the one provided by modern versions of
// fs-extra once https://github.com/jprichardson/node-fs-extra/pull/520 will
// have been merged (until then, they'll break on devservers/Sandcastle)
let asyncRealpath = (() => {var _ref = _asyncToGenerator(function* (path) {
    return new Promise(function (resolve, reject) {
      realpath(path, function (error, result) {
        if (error) {
          reject(error);
        } else {
          resolve(result);
        }
      });
    });
  });return function asyncRealpath(_x) {return _ref.apply(this, arguments);};})();let runMetro = (() => {var _ref2 = _asyncToGenerator(

  function* (_ref3)




  {let config = _ref3.config;var _ref3$maxWorkers = _ref3.maxWorkers;let maxWorkers = _ref3$maxWorkers === undefined ? 1 : _ref3$maxWorkers;var _ref3$projectRoots = _ref3.projectRoots;let projectRoots = _ref3$projectRoots === undefined ? [] : _ref3$projectRoots;var _ref3$watch = _ref3.watch;let watch = _ref3$watch === undefined ? false : _ref3$watch;
    const normalizedConfig = config ? normalizeConfig(config) : DEFAULT_CONFIG;

    const assetExts =
    normalizedConfig.getAssetExts && normalizedConfig.getAssetExts() || [];
    const sourceExts =
    normalizedConfig.getSourceExts && normalizedConfig.getSourceExts() || [];
    const platforms =
    normalizedConfig.getPlatforms && normalizedConfig.getPlatforms() || [];

    const transformModulePath = false ?
    `` :
    normalizedConfig.getTransformModulePath();

    const providesModuleNodeModules =
    typeof normalizedConfig.getProvidesModuleNodeModules === 'function' ?
    normalizedConfig.getProvidesModuleNodeModules() :
    defaultProvidesModuleNodeModules;

    const serverOptions = {
      assetExts: defaultAssetExts.concat(assetExts),
      assetRegistryPath: normalizedConfig.assetRegistryPath,
      blacklistRE: normalizedConfig.getBlacklistRE(),
      extraNodeModules: normalizedConfig.extraNodeModules,
      getPolyfills: normalizedConfig.getPolyfills,
      getModulesRunBeforeMainModule:
      normalizedConfig.getModulesRunBeforeMainModule,
      getTransformOptions: normalizedConfig.getTransformOptions,
      globalTransformCache: null,
      hasteImpl: normalizedConfig.hasteImpl,
      maxWorkers,
      platforms: defaultPlatforms.concat(platforms),
      postMinifyProcess: normalizedConfig.postMinifyProcess,
      postProcessModules: normalizedConfig.postProcessModules,
      postProcessBundleSourcemap: normalizedConfig.postProcessBundleSourcemap,
      providesModuleNodeModules,
      resetCache: false,
      reporter: new TerminalReporter(new Terminal(process.stdout)),
      sourceExts: defaultSourceExts.concat(sourceExts),
      transformCache: TransformCaching.useTempDir(),
      transformModulePath,
      watch,
      workerPath:
      normalizedConfig.getWorkerPath && normalizedConfig.getWorkerPath(),
      projectRoots: yield Promise.all(
      normalizedConfig.
      getProjectRoots().
      concat(projectRoots).
      map(function (path) {return asyncRealpath(path);})) };



    return new MetroServer(serverOptions);
  });return function runMetro(_x2) {return _ref2.apply(this, arguments);};})();function _asyncToGenerator(fn) {return function () {var gen = fn.apply(this, arguments);return new Promise(function (resolve, reject) {function step(key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {return Promise.resolve(value).then(function (value) {step("next", value);}, function (err) {step("throw", err);});}}return step("next");});};}const Http = require('http');const Https = require('https');const MetroBundler = require('./shared/output/bundle');const MetroServer = require('./Server');const Terminal = require('./lib/Terminal');const TerminalReporter = require('./lib/TerminalReporter');const TransformCaching = require('./lib/TransformCaching');const connect = require('connect');var _require = require('fs');const realpath = _require.realpath;var _require2 = require('fs-extra');const readFile = _require2.readFile;const defaultAssetExts = require('./defaults').assetExts;const defaultSourceExts = require('./defaults').sourceExts;const defaultPlatforms = require('./defaults').platforms;const defaultProvidesModuleNodeModules = require('./defaults').providesModuleNodeModules;const DEFAULT_CONFIG = require('./Config').DEFAULT;const normalizeConfig = require('./Config').normalize;





exports.createConnectMiddleware = (() => {var _ref4 = _asyncToGenerator(function* (
  options)
  {
    const metroServer = yield runMetro({
      config: options.config,
      maxWorkers: options.maxWorkers,
      projectRoots: options.projectRoots,
      watch: true });


    return function (req, res) {
      return metroServer.processRequest(req, res);
    };
  });return function (_x3) {return _ref4.apply(this, arguments);};})();











exports.runServer = (() => {var _ref5 = _asyncToGenerator(function* (options) {
    const serverApp = connect();

    const metroMiddleware = exports.createConnectMiddleware({
      config: options.config,
      maxWorkers: options.maxWorkers,
      projectRoots: options.projectRoots });


    serverApp.use(metroMiddleware);

    let httpServer;

    if (options.secure) {
      httpServer = Https.createServer(
      {
        key: yield readFile(options.secureKey),
        cert: yield readFile(options.secureCert) },

      serverApp);

    } else {
      httpServer = Http.createServer(serverApp);
    }

    // $FlowFixMe: The port parameter IS optional
    httpServer.listen(options.port, options.host, function () {
      options.onReady && options.onReady(httpServer);
    });

    // Disable any kind of automatic timeout behavior for incoming
    // requests in case it takes the packager more than the default
    // timeout of 120 seconds to respond to a request.
    httpServer.timeout = 0;

    return new Promise(function (resolve, reject) {
      httpServer.on('error', function (error) {
        reject(error);
      });

      httpServer.on('close', function () {
        resolve();
      });
    });
  });return function (_x4) {return _ref5.apply(this, arguments);};})();












exports.runBuild = (() => {var _ref6 = _asyncToGenerator(function* (options) {
    const metroServer = yield runMetro({
      config: options.config,
      maxWorkers: options.maxWorkers,
      projectRoots: options.projectRoots });


    const requestOptions = {
      dev: options.dev,
      entryFile: options.entry,
      generateSourceMaps: options.sourceMap || !!options.sourceMapUrl,
      inlineSourceMap: options.sourceMap && !!options.sourceMapUrl,
      minify: options.optimize || false,
      platform: options.platform || `web`,
      sourceMapUrl: options.sourceMapUrl };


    const metroBundle = yield MetroBundler.build(metroServer, requestOptions);

    const outputOptions = {
      bundleOutput: options.out.replace(/(\.js)?$/, '.js'),
      dev: options.dev,
      platform: options.platform || `web` };


    yield MetroBundler.save(metroBundle, outputOptions, console.log);
    yield metroServer.end();

    return { metroServer, metroBundle };
  });return function (_x5) {return _ref6.apply(this, arguments);};})();

// The symbols below belong to the legacy API and should not be relied upon
Object.assign(exports, require('./legacy'));